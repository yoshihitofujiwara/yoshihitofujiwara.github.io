/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/002/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/three/examples/js/effects/OutlineEffect.js":
/*!*****************************************************************!*\
  !*** ./node_modules/three/examples/js/effects/OutlineEffect.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author takahirox / http://github.com/takahirox/\n *\n * Reference: https://en.wikipedia.org/wiki/Cel_shading\n *\n * // How to set default outline parameters\n * new THREE.OutlineEffect( renderer, {\n * \tdefaultThickNess: 0.01,\n * \tdefaultColor: [ 0, 0, 0 ],\n * \tdefaultAlpha: 0.8,\n * \tdefaultKeepAlive: true // keeps outline material in cache even if material is removed from scene\n * } );\n *\n * // How to set outline parameters for each material\n * material.userData.outlineParameters = {\n * \tthickNess: 0.01,\n * \tcolor: [ 0, 0, 0 ]\n * \talpha: 0.8,\n * \tvisible: true,\n * \tkeepAlive: true\n * };\n *\n * TODO\n *  - support shader material without objectNormal in its vertexShader\n */\n\nTHREE.OutlineEffect = function ( renderer, parameters ) {\n\n\tparameters = parameters || {};\n\n\tthis.enabled = true;\n\n\tvar defaultThickness = parameters.defaultThickness !== undefined ? parameters.defaultThickness : 0.003;\n\tvar defaultColor = new THREE.Color().fromArray( parameters.defaultColor !== undefined ? parameters.defaultColor : [ 0, 0, 0 ] );\n\tvar defaultAlpha = parameters.defaultAlpha !== undefined ? parameters.defaultAlpha : 1.0;\n\tvar defaultKeepAlive = parameters.defaultKeepAlive !== undefined ? parameters.defaultKeepAlive : false;\n\n\t// object.material.uuid -> outlineMaterial or\n\t// object.material[ n ].uuid -> outlineMaterial\n\t// save at the outline material creation and release\n\t// if it's unused removeThresholdCount frames\n\t// unless keepAlive is true.\n\tvar cache = {};\n\n\tvar removeThresholdCount = 60;\n\n\t// outlineMaterial.uuid -> object.material or\n\t// outlineMaterial.uuid -> object.material[ n ]\n\t// save before render and release after render.\n\tvar originalMaterials = {};\n\n\t// object.uuid -> originalOnBeforeRender\n\t// save before render and release after render.\n\tvar originalOnBeforeRenders = {};\n\n\t//this.cache = cache;  // for debug\n\n\t// copied from WebGLPrograms and removed some materials\n\tvar shaderIDs = {\n\t\tMeshBasicMaterial: 'basic',\n\t\tMeshLambertMaterial: 'lambert',\n\t\tMeshPhongMaterial: 'phong',\n\t\tMeshToonMaterial: 'phong',\n\t\tMeshStandardMaterial: 'physical',\n\t\tMeshPhysicalMaterial: 'physical'\n\t};\n\n\tvar uniformsChunk = {\n\t\toutlineThickness: { type: \"f\", value: defaultThickness },\n\t\toutlineColor: { type: \"c\", value: defaultColor },\n\t\toutlineAlpha: { type: \"f\", value: defaultAlpha }\n\t};\n\n\tvar vertexShaderChunk = [\n\n\t\t\"#include <fog_pars_vertex>\",\n\n\t\t\"uniform float outlineThickness;\",\n\n\t\t\"vec4 calculateOutline( vec4 pos, vec3 objectNormal, vec4 skinned ) {\",\n\n\t\t\"\tfloat thickness = outlineThickness;\",\n\t\t\"\tconst float ratio = 1.0;\", // TODO: support outline thickness ratio for each vertex\n\t\t\"\tvec4 pos2 = projectionMatrix * modelViewMatrix * vec4( skinned.xyz + objectNormal, 1.0 );\",\n\t\t// NOTE: subtract pos2 from pos because BackSide objectNormal is negative\n\t\t\"\tvec4 norm = normalize( pos - pos2 );\",\n\t\t\"\treturn pos + norm * thickness * pos.w * ratio;\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" );\n\n\tvar vertexShaderChunk2 = [\n\n\t\t\"#if ! defined( LAMBERT ) && ! defined( PHONG ) && ! defined( TOON ) && ! defined( PHYSICAL )\",\n\t\t\"\t#ifndef USE_ENVMAP\",\n\t\t\"\t\tvec3 objectNormal = normalize( normal );\",\n\t\t\"\t#endif\",\n\t\t\"#endif\",\n\n\t\t\"#ifdef FLIP_SIDED\",\n\t\t\"\tobjectNormal = -objectNormal;\",\n\t\t\"#endif\",\n\n\t\t\"#ifdef DECLARE_TRANSFORMED\",\n\t\t\"\tvec3 transformed = vec3( position );\",\n\t\t\"#endif\",\n\n\t\t\"gl_Position = calculateOutline( gl_Position, objectNormal, vec4( transformed, 1.0 ) );\",\n\n\t\t\"#include <fog_vertex>\"\n\n\t].join( \"\\n\" );\n\n\tvar fragmentShader = [\n\n\t\t\"#include <common>\",\n\t\t\"#include <fog_pars_fragment>\",\n\n\t\t\"uniform vec3 outlineColor;\",\n\t\t\"uniform float outlineAlpha;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tgl_FragColor = vec4( outlineColor, outlineAlpha );\",\n\n\t\t\"\t#include <fog_fragment>\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" );\n\n\tfunction createInvisibleMaterial() {\n\n\t\treturn new THREE.ShaderMaterial( { name: 'invisible', visible: false } );\n\n\t}\n\n\tfunction createMaterial( originalMaterial ) {\n\n\t\tvar shaderID = shaderIDs[ originalMaterial.type ];\n\t\tvar originalUniforms, originalVertexShader;\n\t\tvar outlineParameters = originalMaterial.userData.outlineParameters;\n\n\t\tif ( shaderID !== undefined ) {\n\n\t\t\tvar shader = THREE.ShaderLib[ shaderID ];\n\t\t\toriginalUniforms = shader.uniforms;\n\t\t\toriginalVertexShader = shader.vertexShader;\n\n\t\t} else if ( originalMaterial.isRawShaderMaterial === true ) {\n\n\t\t\toriginalUniforms = originalMaterial.uniforms;\n\t\t\toriginalVertexShader = originalMaterial.vertexShader;\n\n\t\t\tif ( ! /attribute\\s+vec3\\s+position\\s*;/.test( originalVertexShader ) ||\n\t\t\t     ! /attribute\\s+vec3\\s+normal\\s*;/.test( originalVertexShader ) ) {\n\n\t\t\t\tconsole.warn( 'THREE.OutlineEffect requires both vec3 position and normal attributes in vertex shader, ' +\n\t\t\t\t              'does not draw outline for ' + originalMaterial.name + '(uuid:' + originalMaterial.uuid + ') material.' );\n\n\t\t\t\treturn createInvisibleMaterial();\n\n\t\t\t}\n\n\t\t} else if ( originalMaterial.isShaderMaterial === true ) {\n\n\t\t\toriginalUniforms = originalMaterial.uniforms;\n\t\t\toriginalVertexShader = originalMaterial.vertexShader;\n\n\t\t} else {\n\n\t\t\treturn createInvisibleMaterial();\n\n\t\t}\n\n\t\tvar uniforms = Object.assign( {}, originalUniforms, uniformsChunk );\n\n\t\tvar vertexShader = originalVertexShader\n\t\t\t\t\t// put vertexShaderChunk right before \"void main() {...}\"\n\t\t\t\t\t.replace( /void\\s+main\\s*\\(\\s*\\)/, vertexShaderChunk + '\\nvoid main()' )\n\t\t\t\t\t// put vertexShaderChunk2 the end of \"void main() {...}\"\n\t\t\t\t\t// Note: here assums originalVertexShader ends with \"}\" of \"void main() {...}\"\n\t\t\t\t\t.replace( /\\}\\s*$/, vertexShaderChunk2 + '\\n}' )\n\t\t\t\t\t// remove any light related lines\n\t\t\t\t\t// Note: here is very sensitive to originalVertexShader\n\t\t\t\t\t// TODO: consider safer way\n\t\t\t\t\t.replace( /#include\\s+<[\\w_]*light[\\w_]*>/g, '' );\n\n\t\tvar defines = {};\n\n\t\tif ( ! /vec3\\s+transformed\\s*=/.test( originalVertexShader ) &&\n\t\t     ! /#include\\s+<begin_vertex>/.test( originalVertexShader ) ) defines.DECLARE_TRANSFORMED = true;\n\n\t\treturn new THREE.ShaderMaterial( {\n\t\t\tdefines: defines,\n\t\t\tuniforms: uniforms,\n\t\t\tvertexShader: vertexShader,\n\t\t\tfragmentShader: fragmentShader,\n\t\t\tside: THREE.BackSide,\n\t\t\t//wireframe: true,\n\t\t\tskinning: false,\n\t\t\tmorphTargets: false,\n\t\t\tmorphNormals: false,\n\t\t\tfog: false\n\t\t} );\n\n\t}\n\n\tfunction getOutlineMaterialFromCache( originalMaterial ) {\n\n\t\tvar data = cache[ originalMaterial.uuid ];\n\n\t\tif ( data === undefined ) {\n\n\t\t\tdata = {\n\t\t\t\tmaterial: createMaterial( originalMaterial ),\n\t\t\t\tused: true,\n\t\t\t\tkeepAlive: defaultKeepAlive,\n\t\t\t\tcount: 0\n\t\t\t};\n\n\t\t\tcache[ originalMaterial.uuid ] = data;\n\n\t\t}\n\n\t\tdata.used = true;\n\n\t\treturn data.material;\n\n\t}\n\n\tfunction getOutlineMaterial( originalMaterial ) {\n\n\t\tvar outlineMaterial = getOutlineMaterialFromCache( originalMaterial );\n\n\t\toriginalMaterials[ outlineMaterial.uuid ] = originalMaterial;\n\n\t\tupdateOutlineMaterial( outlineMaterial, originalMaterial );\n\n\t\treturn outlineMaterial;\n\n\t}\n\n\tfunction setOutlineMaterial( object ) {\n\n\t\tif ( object.material === undefined ) return;\n\n\t\tif ( Array.isArray( object.material ) ) {\n\n\t\t\tfor ( var i = 0, il = object.material.length; i < il; i ++ ) {\n\n\t\t\t\tobject.material[ i ] = getOutlineMaterial( object.material[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tobject.material = getOutlineMaterial( object.material );\n\n\t\t}\n\n\t\toriginalOnBeforeRenders[ object.uuid ] = object.onBeforeRender;\n\t\tobject.onBeforeRender = onBeforeRender;\n\n\t}\n\n\tfunction restoreOriginalMaterial( object ) {\n\n\t\tif ( object.material === undefined ) return;\n\n\t\tif ( Array.isArray( object.material ) ) {\n\n\t\t\tfor ( var i = 0, il = object.material.length; i < il; i ++ ) {\n\n\t\t\t\tobject.material[ i ] = originalMaterials[ object.material[ i ].uuid ];\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tobject.material = originalMaterials[ object.material.uuid ];\n\n\t\t}\n\n\t\tobject.onBeforeRender = originalOnBeforeRenders[ object.uuid ];\n\n\t}\n\n\tfunction onBeforeRender( renderer, scene, camera, geometry, material, group ) {\n\n\t\tvar originalMaterial = originalMaterials[ material.uuid ];\n\n\t\t// just in case\n\t\tif ( originalMaterial === undefined ) return;\n\n\t\tupdateUniforms( material, originalMaterial );\n\n\t}\n\n\tfunction updateUniforms( material, originalMaterial ) {\n\n\t\tvar outlineParameters = originalMaterial.userData.outlineParameters;\n\n\t\tmaterial.uniforms.outlineAlpha.value = originalMaterial.opacity;\n\n\t\tif ( outlineParameters !== undefined ) {\n\n\t\t\tif ( outlineParameters.thickness !== undefined ) material.uniforms.outlineThickness.value = outlineParameters.thickness;\n\t\t\tif ( outlineParameters.color !== undefined ) material.uniforms.outlineColor.value.fromArray( outlineParameters.color );\n\t\t\tif ( outlineParameters.alpha !== undefined ) material.uniforms.outlineAlpha.value = outlineParameters.alpha;\n\n\t\t}\n\n\t}\n\n\tfunction updateOutlineMaterial( material, originalMaterial ) {\n\n\t\tif ( material.name === 'invisible' ) return;\n\n\t\tvar outlineParameters = originalMaterial.userData.outlineParameters;\n\n\t\tmaterial.skinning = originalMaterial.skinning;\n\t\tmaterial.morphTargets = originalMaterial.morphTargets;\n\t\tmaterial.morphNormals = originalMaterial.morphNormals;\n\t\tmaterial.fog = originalMaterial.fog;\n\n\t\tif ( outlineParameters !== undefined ) {\n\n\t\t\tif ( originalMaterial.visible === false ) {\n\n\t\t\t\tmaterial.visible = false;\n\n\t\t\t} else {\n\n\t\t\t\tmaterial.visible = ( outlineParameters.visible !== undefined ) ? outlineParameters.visible : true;\n\n\t\t\t}\n\n\t\t\tmaterial.transparent = ( outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0 ) ? true : originalMaterial.transparent;\n\n\t\t\tif ( outlineParameters.keepAlive !== undefined ) cache[ originalMaterial.uuid ].keepAlive = outlineParameters.keepAlive;\n\n\t\t} else {\n\n\t\t\tmaterial.transparent = originalMaterial.transparent;\n\t\t\tmaterial.visible = originalMaterial.visible;\n\n\t\t}\n\n\t\tif ( originalMaterial.wireframe === true || originalMaterial.depthTest === false ) material.visible = false;\n\n\t}\n\n\tfunction cleanupCache() {\n\n\t\tvar keys;\n\n\t\t// clear originialMaterials\n\t\tkeys = Object.keys( originalMaterials );\n\n\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\toriginalMaterials[ keys[ i ] ] = undefined;\n\n\t\t}\n\n\t\t// clear originalOnBeforeRenders\n\t\tkeys = Object.keys( originalOnBeforeRenders );\n\n\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\toriginalOnBeforeRenders[ keys[ i ] ] = undefined;\n\n\t\t}\n\n\t\t// remove unused outlineMaterial from cache\n\t\tkeys = Object.keys( cache );\n\n\t\tfor ( var i = 0, il = keys.length; i < il; i ++ ) {\n\n\t\t\tvar key = keys[ i ];\n\n\t\t\tif ( cache[ key ].used === false ) {\n\n\t\t\t\tcache[ key ].count++;\n\n\t\t\t\tif ( cache[ key ].keepAlive === false && cache[ key ].count > removeThresholdCount ) {\n\n\t\t\t\t\tdelete cache[ key ];\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tcache[ key ].used = false;\n\t\t\t\tcache[ key ].count = 0;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\n\t\tif ( this.enabled === false ) {\n\n\t\t\trenderer.render( scene, camera, renderTarget, forceClear );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar currentAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = this.autoClear;\n\n\t\t// 1. render normally\n\t\trenderer.render( scene, camera, renderTarget, forceClear );\n\n\t\t// 2. render outline\n\t\tvar currentSceneAutoUpdate = scene.autoUpdate;\n\t\tvar currentSceneBackground = scene.background;\n\t\tvar currentShadowMapEnabled = renderer.shadowMap.enabled;\n\n\t\tscene.autoUpdate = false;\n\t\tscene.background = null;\n\t\trenderer.autoClear = false;\n\t\trenderer.shadowMap.enabled = false;\n\n\t\tscene.traverse( setOutlineMaterial );\n\n\t\trenderer.render( scene, camera, renderTarget );\n\n\t\tscene.traverse( restoreOriginalMaterial );\n\n\t\tcleanupCache();\n\n\t\tscene.autoUpdate = currentSceneAutoUpdate;\n\t\tscene.background = currentSceneBackground;\n\t\trenderer.autoClear = currentAutoClear;\n\t\trenderer.shadowMap.enabled = currentShadowMapEnabled;\n\n\t};\n\n\t/*\n\t * See #9918\n\t *\n\t * The following property copies and wrapper methods enable\n\t * THREE.OutlineEffect to be called from other *Effect, like\n\t *\n\t * effect = new THREE.StereoEffect( new THREE.OutlineEffect( renderer ) );\n\t *\n\t * function render () {\n\t *\n \t * \teffect.render( scene, camera );\n\t *\n\t * }\n\t */\n\tthis.autoClear = renderer.autoClear;\n\tthis.domElement = renderer.domElement;\n\tthis.shadowMap = renderer.shadowMap;\n\n\tthis.clear = function ( color, depth, stencil ) {\n\n\t\trenderer.clear( color, depth, stencil );\n\n\t};\n\n\tthis.getPixelRatio = function () {\n\n\t\treturn renderer.getPixelRatio();\n\n\t};\n\n\tthis.setPixelRatio = function ( value ) {\n\n\t\trenderer.setPixelRatio( value );\n\n\t};\n\n\tthis.getSize = function () {\n\n\t\treturn renderer.getSize();\n\n\t};\n\n\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\trenderer.setSize( width, height, updateStyle );\n\n\t};\n\n\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\trenderer.setViewport( x, y, width, height );\n\n\t};\n\n\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\trenderer.setScissor( x, y, width, height );\n\n\t};\n\n\tthis.setScissorTest = function ( boolean ) {\n\n\t\trenderer.setScissorTest( boolean );\n\n\t};\n\n\tthis.setRenderTarget = function ( renderTarget ) {\n\n\t\trenderer.setRenderTarget( renderTarget );\n\n\t};\n\n};\n\n\n//# sourceURL=webpack:///./node_modules/three/examples/js/effects/OutlineEffect.js?");

/***/ }),

/***/ "./src/js/002/index.js":
/*!*****************************!*\
  !*** ./src/js/002/index.js ***!
  \*****************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_Render__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Render */ \"./src/js/utils/Render.js\");\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n__webpack_require__(/*! three/examples/js/effects/OutlineEffect.js */ \"./node_modules/three/examples/js/effects/OutlineEffect.js\");\n\nvar render = void 0,\n    loader = void 0,\n    texture = void 0,\n    shader = void 0,\n    uniforms = void 0,\n    group = void 0,\n    webCamera = void 0,\n    img = void 0,\n    params = {},\n    is3D = false,\n    width = 1920,\n    height = 1080,\n    size = {\n\twidth: 2,\n\theight: 2\n};\n\nif (AMP.queryHashMap().is3D) {\n\tis3D = true;\n}\n\n/**\r\n * @calss Sketch\r\n */\n\nvar Sketch = function () {\n\t/**\r\n  * constructor\r\n  */\n\tfunction Sketch() {\n\t\tvar _this = this;\n\n\t\t_classCallCheck(this, Sketch);\n\n\t\tloader = new THREE.TextureLoader();\n\n\t\twebCamera = new AMP.WebCamera($('#webcamera')[0], {\n\t\t\tconstraints: {\n\t\t\t\tvideo: {\n\t\t\t\t\twidth: width,\n\t\t\t\t\theight: height\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\twebCamera.setup().on('load', function () {\n\t\t\t// webCamera.play();\n\t\t\t// this.setup();\n\t\t});\n\n\t\trender = new _utils_Render__WEBPACK_IMPORTED_MODULE_0__[\"default\"]($('#canvas_container'), {\n\t\t\tis3D: is3D,\n\t\t\tisController: true\n\t\t});\n\n\t\tloader.load(\"img/photo04.jpg\", function (_texture) {\n\t\t\timg = _texture.image;\n\t\t\ttexture = _texture;\n\t\t\ttexture.minFilter = THREE.LinearFilter;\n\t\t\ttexture.magFilter = THREE.LinearFilter;\n\t\t\ttexture.format = THREE.RGBFormat;\n\n\t\t\t_this.setup();\n\t\t});\n\t}\n\n\t/**\r\n  * renderStart\r\n  */\n\n\n\t_createClass(Sketch, [{\n\t\tkey: 'renderStart',\n\t\tvalue: function renderStart() {\n\t\t\tvar _this2 = this;\n\n\t\t\trender.event.on(\"update\", function () {\n\t\t\t\tuniforms.uTime.value = render.time;\n\t\t\t\tuniforms.uTime2.value = render.time;\n\t\t\t});\n\t\t\trender.resize(width, height);\n\t\t\trender.start();\n\n\t\t\trender.event.on(\"inputImg\", function (_img) {\n\t\t\t\tloader.load(_img.src, function (_texture) {\n\t\t\t\t\timg = _texture.image;\n\t\t\t\t\ttexture = _texture;\n\t\t\t\t\tuniforms.texture.value = texture;\n\t\t\t\t\trender.resize(_img.width, _img.height);\n\t\t\t\t\t_this2.generateGeometry();\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t/**\r\n   * setup\r\n   */\n\n\t}, {\n\t\tkey: 'setup',\n\t\tvalue: function setup() {\n\t\t\tvar webCameraTexture = new THREE.VideoTexture(webCamera.video);\n\t\t\twebCameraTexture.minFilter = THREE.LinearFilter;\n\t\t\twebCameraTexture.magFilter = THREE.LinearFilter;\n\t\t\twebCameraTexture.format = THREE.RGBFormat;\n\n\t\t\tvar textureObj = {\n\t\t\t\ttypes: [\"image\", \"webCamera\"],\n\t\t\t\ttexture: \"image\",\n\t\t\t\timage: texture,\n\t\t\t\twebCamera: webCameraTexture\n\t\t\t};\n\n\t\t\tuniforms = {\n\t\t\t\ttexture: { type: \"t\", value: texture },\n\t\t\t\ttexture2: { type: \"t\", value: texture },\n\t\t\t\tresolution: { type: \"v2\", value: new THREE.Vector2(1920, 1080) },\n\t\t\t\tuTime: { type: \"f\", value: 0.0 },\n\t\t\t\tuTime2: { type: \"f\", value: 0.0 },\n\t\t\t\tuZamount: { type: \"f\", value: 0 },\n\n\t\t\t\tuBlendMode: { type: \"i\", value: 1 },\n\t\t\t\tuOverLay: { type: \"b\", value: false },\n\t\t\t\tuAmount: { type: \"f\", value: 1.0 },\n\t\t\t\tuColor: { type: \"v4\", value: new THREE.Vector4(1.0, 1.0, 1.0, 1.0) }\n\t\t\t};\n\n\t\t\tvar material = new THREE.ShaderMaterial({\n\t\t\t\tvertexShader: __webpack_require__(/*! ../../shader/sketches/sketch.vert */ \"./src/shader/sketches/sketch.vert\"),\n\t\t\t\tfragmentShader: __webpack_require__(/*! ../../shader/edit/002.frag */ \"./src/shader/edit/002.frag\"),\n\t\t\t\tuniforms: uniforms\n\t\t\t});\n\n\t\t\t// custom material\n\t\t\tmaterial.transparent = true;\n\t\t\tmaterial.blending = THREE.NormalBlending;\n\t\t\tmaterial.side = THREE.DoubleSide;\n\n\t\t\t// dat gui\n\t\t\trender.gui.open();\n\t\t\trender.gui.wireFolder.add(material, \"wireframe\");\n\n\t\t\trender.gui.add(textureObj, \"texture\", textureObj.types).onChange(function (type) {\n\t\t\t\tif (type == \"webCamera\") {\n\t\t\t\t\twebCamera.play();\n\t\t\t\t} else {\n\t\t\t\t\twebCamera.pause();\n\t\t\t\t}\n\t\t\t\tuniforms.texture.value = textureObj[type];\n\t\t\t});\n\n\t\t\tparams.BlendMode = \"Add\";\n\t\t\tvar blendList = [\"Add\", \"Average\", \"ColorBurn\", \"ColorDodge\", \"Darken\", \"Difference\", \"Exclusion\", \"Glow\", \"HardLight\", \"HardMix\", \"Lighten\", \"LinearBurn\", \"LinearDodge\", \"LinearLight\", \"Multiply\", \"Negation\", \"Normal\", \"Overlay\", \"Phoenix\", \"PinLight\", \"Reflect\", \"Screen\", \"SoftLight\", \"Subtract\", \"VividLight\"];\n\n\t\t\trender.gui.add(params, 'BlendMode', blendList).name(\"BlendMode\").onChange(function (data) {\n\t\t\t\tblendList.forEach(function (item, i) {\n\t\t\t\t\tif (item == data) {\n\t\t\t\t\t\tuniforms.uBlendMode.value = i + 1;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t\trender.gui.add(uniforms.uAmount, \"value\", 0, 1).step(0.01).name(\"Amount\");\n\n\t\t\tparams.Color = [255, 255, 255];\n\t\t\trender.gui.addColor(params, \"Color\").onChange(function (data) {\n\t\t\t\tuniforms.uColor.value = new THREE.Vector4(data[0] / 255, data[1] / 255, data[2] / 255, 1.0);\n\t\t\t});\n\n\t\t\trender.gui.add(uniforms.uOverLay, \"value\").name(\"FileOverLay\");\n\n\t\t\t// input file\n\t\t\tvar $file = $(\"#file2\");\n\t\t\tif ($file[0]) {\n\t\t\t\tvar fileReader = new FileReader(),\n\t\t\t\t    _img2 = new Image();\n\n\t\t\t\t$file.change(function () {\n\t\t\t\t\tif (this.files && this.files[0] && this.files[0].type.indexOf(\"image/\") > -1) {\n\t\t\t\t\t\tfileReader.readAsDataURL(this.files[0]);\n\t\t\t\t\t}\n\t\t\t\t\t$(this).val(\"\");\n\t\t\t\t});\n\n\t\t\t\tfileReader.addEventListener('load', function (event) {\n\t\t\t\t\t_img2.src = event.target.result;\n\n\t\t\t\t\tloader.load(_img2.src, function (_texture) {\n\t\t\t\t\t\t// img = _texture.image;\n\t\t\t\t\t\tuniforms.texture2.value = _texture;\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tparams.inputFile = function () {\n\t\t\t\t\t$file.click();\n\t\t\t\t};\n\t\t\t\trender.gui.add(params, \"inputFile\");\n\t\t\t}\n\n\t\t\tif (is3D) {\n\t\t\t\tsize.width = width / 150;\n\t\t\t\tsize.height = height / 150;\n\t\t\t}\n\n\t\t\tgroup = new THREE.Group();\n\t\t\tvar geometry = new THREE.PlaneBufferGeometry(size.width, size.width, 1, 1);\n\t\t\tvar lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0 });\n\t\t\tvar mesh = new THREE.Mesh(geometry, material);\n\n\t\t\tgroup.add(new THREE.LineSegments(geometry, lineMaterial));\n\t\t\tgroup.add(mesh);\n\n\t\t\tparams.widthSegments = 10;\n\t\t\tparams.widthSegments = 10;\n\t\t\tparams.heightSegments = 10;\n\n\t\t\trender.gui.wireFolder.add(params, 'widthSegments', 1, 300).step(1).onChange(this.generateGeometry.bind(this));\n\t\t\trender.gui.wireFolder.add(params, 'heightSegments', 1, 300).step(1).onChange(this.generateGeometry.bind(this));\n\n\t\t\tif (is3D) {\n\t\t\t\trender.gui.wireFolder.add(uniforms.uZamount, 'value').min(0).max(10).step(0.01).name(\"Z Amount\");\n\t\t\t}\n\n\t\t\trender.scene.add(group);\n\n\t\t\t// render\n\t\t\tthis.renderStart();\n\t\t\tthis.generateGeometry();\n\t\t}\n\n\t\t/**\r\n   * [generateGeometry description]\r\n   * @return {[type]} [description]\r\n   */\n\n\t}, {\n\t\tkey: 'generateGeometry',\n\t\tvalue: function generateGeometry() {\n\t\t\tif (is3D) {\n\t\t\t\tsize.width = img.width / 150;\n\t\t\t\tsize.height = img.height / 150;\n\t\t\t} else {\n\t\t\t\tsize.width = 2;\n\t\t\t\tsize.height = 2;\n\t\t\t}\n\n\t\t\tvar geometry = new THREE.PlaneGeometry(size.width, size.height, params.widthSegments, params.heightSegments);\n\t\t\tgroup.children[0].geometry.dispose();\n\t\t\tgroup.children[1].geometry.dispose();\n\t\t\tgroup.children[0].geometry = new THREE.WireframeGeometry(geometry);\n\t\t\tgroup.children[1].geometry = geometry;\n\t\t}\n\t}]);\n\n\treturn Sketch;\n}();\n\n/*==========================================================================\r\n\tDOM READY\r\n==========================================================================*/\n\n\n$(function () {\n\tnew Sketch();\n});\n\n//# sourceURL=webpack:///./src/js/002/index.js?");

/***/ }),

/***/ "./src/js/utils/Render.js":
/*!********************************!*\
  !*** ./src/js/utils/Render.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Render = function () {\n\t/**\r\n  * constructor\r\n  * @param  {jQuery} $container canvas container\r\n  * @param  {Object} oprions\r\n  */\n\tfunction Render($container, options) {\n\t\tvar _this = this;\n\n\t\t_classCallCheck(this, Render);\n\n\t\tthis.$container = $container;\n\t\tthis.width = 600;\n\t\tthis.height = 480;\n\n\t\tthis.options = $.extend(true, {\n\t\t\tis3D: false,\n\t\t\tisController: false,\n\t\t\tisAxis: false,\n\t\t\tisGui: true\n\t\t}, options);\n\n\t\tthis.startTime = null;\n\t\tthis.time = null;\n\n\t\t// event: [start, stop, resize, update]\n\t\tthis.event = new AMP.Events();\n\n\t\tthis.isDebug = -1 < location.href.indexOf('http://localhost');\n\n\t\t// stats\n\t\tthis.stats = new Stats();\n\t\tthis.$container[0].appendChild(this.stats.dom);\n\n\t\tif (this.isDebug) {\n\t\t\t$(this.stats.domElement).css({ display: 'block' });\n\t\t} else {\n\t\t\t$(this.stats.domElement).css({ display: 'none' });\n\t\t}\n\n\t\t// gui\n\t\tif (this.options.isGui) {\n\t\t\tthis.gui = new dat.GUI();\n\t\t\tthis.gui.commonFolder = this.gui.addFolder(\"common\");\n\t\t\tthis.gui.wireFolder = this.gui.addFolder(\"wire\");\n\n\t\t\tif (!AMP.hasHash(\"guiopen\")) {\n\t\t\t\tthis.gui.close();\n\t\t\t}\n\t\t\tthis.gui.params = {};\n\n\t\t\tthis.gui.params.stats = this.isDebug;\n\n\t\t\tthis.gui.commonFolder.add(this.gui.params, 'stats').name('FPS Metor').onChange(function () {\n\t\t\t\tif (_this.gui.params.stats) {\n\t\t\t\t\t$(_this.stats.domElement).css('display', 'block');\n\t\t\t\t} else {\n\t\t\t\t\t$(_this.stats.domElement).css('display', 'none');\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (this.isDebug) {\n\t\t\t\tthis.gui.open();\n\t\t\t}\n\t\t}\n\n\t\t// input file\n\t\tvar $file = $(\"#file\");\n\t\tif ($file[0]) {\n\t\t\tvar fileReader = new FileReader(),\n\t\t\t    img = new Image();\n\n\t\t\t$file.change(function () {\n\t\t\t\tif (this.files && this.files[0] && this.files[0].type.indexOf(\"image/\") > -1) {\n\t\t\t\t\tfileReader.readAsDataURL(this.files[0]);\n\t\t\t\t}\n\t\t\t\t$(this).val(\"\");\n\t\t\t});\n\n\t\t\tfileReader.addEventListener('load', function (event) {\n\t\t\t\timg.src = event.target.result;\n\t\t\t\t_this.event.trigger(\"inputImg\", img);\n\t\t\t});\n\n\t\t\tthis.gui.params.inputFile = function () {\n\t\t\t\t$file.click();\n\t\t\t};\n\t\t\tthis.gui.commonFolder.add(this.gui.params, \"inputFile\");\n\t\t}\n\n\t\tthis._animationId = null;\n\n\t\tthis.renderer = new THREE.WebGLRenderer({\n\t\t\tpreserveDrawingBuffer: true\n\t\t});\n\t\tthis.renderer.setClearColor(0x000000);\n\t\tthis.renderer.setPixelRatio(window.devicePixelRatio);\n\t\t// this.renderer.setPixelRatio(1);\n\t\t// this.renderer.setSize(this.width, this.height);\n\t\tthis.scene = new THREE.Scene();\n\n\t\t// saveFile\n\t\tfunction Base64toBlob(base64) {\n\t\t\tvar tmp = base64.split(',');\n\t\t\tvar data = atob(tmp[1]);\n\t\t\tvar mime = tmp[0].split(':')[1].split(';')[0];\n\t\t\tvar buf = new Uint8Array(data.length);\n\t\t\tfor (var i = 0; i < data.length; i++) {\n\t\t\t\tbuf[i] = data.charCodeAt(i);\n\t\t\t}\n\t\t\tvar blob = new Blob([buf], { type: mime });\n\t\t\treturn blob;\n\t\t}\n\n\t\tfunction saveBlob(blob, fileName) {\n\t\t\tvar url = window.URL || window.webkitURL;\n\t\t\tvar dataUrl = url.createObjectURL(blob);\n\t\t\tvar event = document.createEvent(\"MouseEvents\");\n\t\t\tevent.initMouseEvent(\"click\", true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n\t\t\tvar a = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"a\");\n\t\t\ta.href = dataUrl;\n\t\t\ta.download = fileName;\n\t\t\ta.dispatchEvent(event);\n\t\t}\n\n\t\tthis.gui.params.saveFile = function () {\n\t\t\tvar base64 = _this.renderer.domElement.toDataURL();\n\t\t\tvar blob = Base64toBlob(base64);\n\t\t\tsaveBlob(blob, \"img\" + $.now() + \".jpg\");\n\t\t};\n\n\t\tthis.gui.commonFolder.add(this.gui.params, \"saveFile\");\n\n\t\t// Camera: 2D or 3D\n\t\tif (this.options.is3D) {\n\t\t\tthis.camera = new THREE.PerspectiveCamera(90, this.width / this.height, 0.1, 1000);\n\t\t\tthis.camera.position.set(0, 0, 5);\n\t\t\tthis.camera.aspect = this.width / this.height;\n\n\t\t\tif (this.options.isController) {\n\t\t\t\tthis.controller = new THREE.OrbitControls(this.camera, this.renderer.domElement);\n\t\t\t\tthis.controller.autoRotate = false;\n\t\t\t\tthis.controller.autoRotateSpeed = 5.0;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.camera = new THREE.Camera();\n\t\t\t// this.camera = new THREE.OrthographicCamera(this.width/-2,this.width/2,this.height/2,this.height/-2, 0.1 , 10000);\n\t\t\t// this.camera.up.set(0,0,1);\n\t\t\t// this.camera.position.z = 1;\n\t\t}\n\n\t\t// AxisHelper\n\t\tif (this.options.isAxis) {\n\t\t\tthis.axis = new THREE.AxisHelper(1000);\n\t\t\tthis.scene.add(this.axis);\n\t\t}\n\n\t\tthis.$container[0].appendChild(this.renderer.domElement);\n\n\t\t// @resize\n\t\t// $(window).resize(this.resize.bind(this));\n\t}\n\n\t/**\r\n  * start\r\n  */\n\n\n\t_createClass(Render, [{\n\t\tkey: 'start',\n\t\tvalue: function start() {\n\t\t\tthis.startTime = AMP.now();\n\t\t\tcancelAnimationFrame(this._animationId);\n\t\t\tthis.event.trigger('start', this);\n\t\t\tthis.update();\n\t\t}\n\n\t\t/**\r\n   * stop\r\n   */\n\n\t}, {\n\t\tkey: 'stop',\n\t\tvalue: function stop() {\n\t\t\tcancelAnimationFrame(this._animationId);\n\t\t\tthis.event.trigger('stop', this);\n\t\t}\n\n\t\t/**\r\n   * update\r\n   */\n\n\t}, {\n\t\tkey: 'update',\n\t\tvalue: function update() {\n\t\t\tthis.time = (AMP.now() - this.startTime) / 1000;\n\t\t\tthis._animationId = requestAnimationFrame(this.update.bind(this));\n\n\t\t\tthis.event.trigger('update', this);\n\n\t\t\tif (this.controller) {\n\t\t\t\tthis.controller.update();\n\t\t\t}\n\n\t\t\tthis.render();\n\n\t\t\tif (this.gui.params.stats) {\n\t\t\t\tthis.stats.update();\n\t\t\t}\n\t\t}\n\n\t\t/**\r\n   * render description\r\n   */\n\n\t}, {\n\t\tkey: 'render',\n\t\tvalue: function render() {\n\t\t\tthis.renderer.render(this.scene, this.camera);\n\t\t}\n\n\t\t/**\r\n   * resize\r\n   */\n\n\t}, {\n\t\tkey: 'resize',\n\t\tvalue: function resize(width, height) {\n\t\t\tthis.width = width;\n\t\t\tthis.height = height;\n\n\t\t\tthis.renderer.setSize(this.width, this.height);\n\n\t\t\tif (this.options.is3D) {\n\t\t\t\tthis.camera.aspect = this.width / this.height;\n\t\t\t\tthis.camera.updateProjectionMatrix();\n\t\t\t} else {\n\t\t\t\t// this.camera.left = -this.width / 2;\n\t\t\t\t// this.camera.right = this.width / 2;\n\t\t\t\t// this.camera.top = this.height / 2;\n\t\t\t\t// this.camera.bottom = -this.height / 2;\n\t\t\t}\n\t\t\tthis.event.trigger('resize', this);\n\t\t}\n\t}]);\n\n\treturn Render;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Render);\n\n//# sourceURL=webpack:///./src/js/utils/Render.js?");

/***/ }),

/***/ "./src/shader/common/define.glsl":
/*!***************************************!*\
  !*** ./src/shader/common/define.glsl ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"#define GLSLIFY 1\\n\\n\\n\\n#define PI 3.14159265358979323846\\n#define HARF_PI (PI / 2.0)\\n#define TWO_PI (PI * 2.0)\\n\\n#define DEG_TO_RAD (PI / 180.0)\\n#define RAD_TO_DEG (180.0 / PI)\\n\\n\\n\\n#define LUMINANCE_R 0.298912\\n#define LUMINANCE_G 0.586611\\n#define LUMINANCE_B 0.114478\\n\\n\\n#define DELTA (1.0 / 60.0)\\nvec3 LUMINANCE = vec3(LUMINANCE_R, LUMINANCE_G, LUMINANCE_B);\\n\"\n\n//# sourceURL=webpack:///./src/shader/common/define.glsl?");

/***/ }),

/***/ "./src/shader/edit/002.frag":
/*!**********************************!*\
  !*** ./src/shader/edit/002.frag ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = \"precision mediump float;\\n#define GLSLIFY 1\\n\\n\" + __webpack_require__(/*! ../common/define.glsl */ \"./src/shader/common/define.glsl\") + \"\\n\\n\\n\\n\\nvarying vec2 vUv;\\n\\nuniform sampler2D texture;\\nuniform sampler2D texture2;\\nuniform float uTime;\\nuniform vec2 resolution;\\n\\n\\nuniform int uBlendMode;\\nuniform float uAmount;\\nuniform vec4 uColor;\\nuniform bool uOverLay;\\n\\n\\n\\n\\n\\n\\n\\nfloat blendColorDodge_12_0(float base, float blend) {\\n\\treturn (blend==1.0)?blend:min(base/(1.0-blend),1.0);\\n}\\n\\nvec3 blendColorDodge_12_0(vec3 base, vec3 blend) {\\n\\treturn vec3(blendColorDodge_12_0(base.r,blend.r),blendColorDodge_12_0(base.g,blend.g),blendColorDodge_12_0(base.b,blend.b));\\n}\\n\\nvec3 blendColorDodge_12_0(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendColorDodge_12_0(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\n\\nfloat blendColorBurn_13_1(float base, float blend) {\\n\\treturn (blend==0.0)?blend:max((1.0-((1.0-base)/blend)),0.0);\\n}\\n\\nvec3 blendColorBurn_13_1(vec3 base, vec3 blend) {\\n\\treturn vec3(blendColorBurn_13_1(base.r,blend.r),blendColorBurn_13_1(base.g,blend.g),blendColorBurn_13_1(base.b,blend.b));\\n}\\n\\nvec3 blendColorBurn_13_1(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendColorBurn_13_1(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\n\\nfloat blendVividLight_6_2(float base, float blend) {\\n\\treturn (blend<0.5)?blendColorBurn_13_1(base,(2.0*blend)):blendColorDodge_12_0(base,(2.0*(blend-0.5)));\\n}\\n\\nvec3 blendVividLight_6_2(vec3 base, vec3 blend) {\\n\\treturn vec3(blendVividLight_6_2(base.r,blend.r),blendVividLight_6_2(base.g,blend.g),blendVividLight_6_2(base.b,blend.b));\\n}\\n\\nvec3 blendVividLight_6_2(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendVividLight_6_2(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\n\\nfloat blendHardMix_2_3(float base, float blend) {\\n\\treturn (blendVividLight_6_2(base,blend)<0.5)?0.0:1.0;\\n}\\n\\nvec3 blendHardMix_2_3(vec3 base, vec3 blend) {\\n\\treturn vec3(blendHardMix_2_3(base.r,blend.r),blendHardMix_2_3(base.g,blend.g),blendHardMix_2_3(base.b,blend.b));\\n}\\n\\nvec3 blendHardMix_2_3(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendHardMix_2_3(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\n\\nfloat blendLinearDodge_14_4(float base, float blend) {\\n\\t// Note : Same implementation as BlendAddf\\n\\treturn min(base+blend,1.0);\\n}\\n\\nvec3 blendLinearDodge_14_4(vec3 base, vec3 blend) {\\n\\t// Note : Same implementation as BlendAdd\\n\\treturn min(base+blend,vec3(1.0));\\n}\\n\\nvec3 blendLinearDodge_14_4(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearDodge_14_4(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\nfloat blendLinearBurn_15_5(float base, float blend) {\\n\\t// Note : Same implementation as BlendSubtractf\\n\\treturn max(base+blend-1.0,0.0);\\n}\\n\\nvec3 blendLinearBurn_15_5(vec3 base, vec3 blend) {\\n\\t// Note : Same implementation as BlendSubtract\\n\\treturn max(base+blend-vec3(1.0),vec3(0.0));\\n}\\n\\nvec3 blendLinearBurn_15_5(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearBurn_15_5(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\n\\nfloat blendLinearLight_1_6(float base, float blend) {\\n\\treturn blend<0.5?blendLinearBurn_15_5(base,(2.0*blend)):blendLinearDodge_14_4(base,(2.0*(blend-0.5)));\\n}\\n\\nvec3 blendLinearLight_1_6(vec3 base, vec3 blend) {\\n\\treturn vec3(blendLinearLight_1_6(base.r,blend.r),blendLinearLight_1_6(base.g,blend.g),blendLinearLight_1_6(base.b,blend.b));\\n}\\n\\nvec3 blendLinearLight_1_6(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearLight_1_6(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\nfloat blendLighten_17_7(float base, float blend) {\\n\\treturn max(blend,base);\\n}\\n\\nvec3 blendLighten_17_7(vec3 base, vec3 blend) {\\n\\treturn vec3(blendLighten_17_7(base.r,blend.r),blendLighten_17_7(base.g,blend.g),blendLighten_17_7(base.b,blend.b));\\n}\\n\\nvec3 blendLighten_17_7(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLighten_17_7(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\nfloat blendDarken_16_8(float base, float blend) {\\n\\treturn min(blend,base);\\n}\\n\\nvec3 blendDarken_16_8(vec3 base, vec3 blend) {\\n\\treturn vec3(blendDarken_16_8(base.r,blend.r),blendDarken_16_8(base.g,blend.g),blendDarken_16_8(base.b,blend.b));\\n}\\n\\nvec3 blendDarken_16_8(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendDarken_16_8(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\n\\nfloat blendPinLight_4_9(float base, float blend) {\\n\\treturn (blend<0.5)?blendDarken_16_8(base,(2.0*blend)):blendLighten_17_7(base,(2.0*(blend-0.5)));\\n}\\n\\nvec3 blendPinLight_4_9(vec3 base, vec3 blend) {\\n\\treturn vec3(blendPinLight_4_9(base.r,blend.r),blendPinLight_4_9(base.g,blend.g),blendPinLight_4_9(base.b,blend.b));\\n}\\n\\nvec3 blendPinLight_4_9(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendPinLight_4_9(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\nfloat blendReflect_11_10(float base, float blend) {\\n\\treturn (blend==1.0)?blend:min(base*base/(1.0-blend),1.0);\\n}\\n\\nvec3 blendReflect_11_10(vec3 base, vec3 blend) {\\n\\treturn vec3(blendReflect_11_10(base.r,blend.r),blendReflect_11_10(base.g,blend.g),blendReflect_11_10(base.b,blend.b));\\n}\\n\\nvec3 blendReflect_11_10(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendReflect_11_10(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\n\\nvec3 blendGlow_3_11(vec3 base, vec3 blend) {\\n\\treturn blendReflect_11_10(blend,base);\\n}\\n\\nvec3 blendGlow_3_11(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendGlow_3_11(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\nfloat blendOverlay_5_12(float base, float blend) {\\n\\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\\n}\\n\\nvec3 blendOverlay_5_12(vec3 base, vec3 blend) {\\n\\treturn vec3(blendOverlay_5_12(base.r,blend.r),blendOverlay_5_12(base.g,blend.g),blendOverlay_5_12(base.b,blend.b));\\n}\\n\\nvec3 blendOverlay_5_12(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendOverlay_5_12(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\n\\nvec3 blendHardLight_7_13(vec3 base, vec3 blend) {\\n\\treturn blendOverlay_5_12(blend,base);\\n}\\n\\nvec3 blendHardLight_7_13(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendHardLight_7_13(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\nvec3 blendPhoenix_9_14(vec3 base, vec3 blend) {\\n\\treturn min(base,blend)-max(base,blend)+vec3(1.0);\\n}\\n\\nvec3 blendPhoenix_9_14(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendPhoenix_9_14(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\n\\nvec3 blendNormal_8_15(vec3 base, vec3 blend) {\\n\\treturn blend;\\n}\\n\\nvec3 blendNormal_8_15(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendNormal_8_15(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\nvec3 blendNegation_10_16(vec3 base, vec3 blend) {\\n\\treturn vec3(1.0)-abs(vec3(1.0)-base-blend);\\n}\\n\\nvec3 blendNegation_10_16(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendNegation_10_16(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\nvec3 blendMultiply_18_17(vec3 base, vec3 blend) {\\n\\treturn base*blend;\\n}\\n\\nvec3 blendMultiply_18_17(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendMultiply_18_17(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\n\\nvec3 blendAverage_19_18(vec3 base, vec3 blend) {\\n\\treturn (base+blend)/2.0;\\n}\\n\\nvec3 blendAverage_19_18(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendAverage_19_18(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\n\\n\\nfloat blendScreen_20_19(float base, float blend) {\\n\\treturn 1.0-((1.0-base)*(1.0-blend));\\n}\\n\\nvec3 blendScreen_20_19(vec3 base, vec3 blend) {\\n\\treturn vec3(blendScreen_20_19(base.r,blend.r),blendScreen_20_19(base.g,blend.g),blendScreen_20_19(base.b,blend.b));\\n}\\n\\nvec3 blendScreen_20_19(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendScreen_20_19(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\nfloat blendSoftLight_21_20(float base, float blend) {\\n\\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\\n}\\n\\nvec3 blendSoftLight_21_20(vec3 base, vec3 blend) {\\n\\treturn vec3(blendSoftLight_21_20(base.r,blend.r),blendSoftLight_21_20(base.g,blend.g),blendSoftLight_21_20(base.b,blend.b));\\n}\\n\\nvec3 blendSoftLight_21_20(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendSoftLight_21_20(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\nfloat blendSubtract_23_21(float base, float blend) {\\n\\treturn max(base+blend-1.0,0.0);\\n}\\n\\nvec3 blendSubtract_23_21(vec3 base, vec3 blend) {\\n\\treturn max(base+blend-vec3(1.0),vec3(0.0));\\n}\\n\\nvec3 blendSubtract_23_21(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendSubtract_23_21(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\nvec3 blendExclusion_22_22(vec3 base, vec3 blend) {\\n\\treturn base+blend-2.0*base*blend;\\n}\\n\\nvec3 blendExclusion_22_22(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendExclusion_22_22(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\nvec3 blendDifference_24_23(vec3 base, vec3 blend) {\\n\\treturn abs(base-blend);\\n}\\n\\nvec3 blendDifference_24_23(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendDifference_24_23(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\n\\n\\n\\nfloat blendAdd_25_24(float base, float blend) {\\n\\treturn min(base+blend,1.0);\\n}\\n\\nvec3 blendAdd_25_24(vec3 base, vec3 blend) {\\n\\treturn min(base+blend,vec3(1.0));\\n}\\n\\nvec3 blendAdd_25_24(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendAdd_25_24(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvoid main() {\\n\\n\\tvec4 bgColor = texture2D( texture, vUv );\\n\\n\\tvec4 fgColor = vec4(1.0);\\n\\tif(uOverLay){\\n\\t\\tfgColor = texture2D( texture2, vUv );\\n\\t} else {\\n\\t\\tfgColor = vec4(uColor);\\n\\t}\\n\\n\\tvec3 color = vec3(0.0);\\n\\n\\tif( uBlendMode == 1 ){\\n\\t\\tcolor = blendAdd_25_24(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}else if( uBlendMode == 2 ){\\n\\t\\tcolor = blendAverage_19_18(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}\\n\\tif( uBlendMode == 3 ){\\n\\t\\tcolor = blendColorBurn_13_1(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}else if( uBlendMode == 4 ){\\n\\t\\tcolor = blendColorDodge_12_0(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}else if( uBlendMode == 5 ){\\n\\t\\tcolor = blendDarken_16_8(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}else if( uBlendMode == 6 ){\\n\\t\\tcolor = blendDifference_24_23(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}else if( uBlendMode == 7 ){\\n\\t\\tcolor = blendExclusion_22_22(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}else if( uBlendMode == 8 ){\\n\\t\\tcolor = blendGlow_3_11(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}else if( uBlendMode == 9 ){\\n\\t\\tcolor = blendHardLight_7_13(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}else if( uBlendMode == 10 ){\\n\\t\\tcolor = blendHardMix_2_3(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}else if( uBlendMode == 11 ){\\n\\t\\tcolor = blendLighten_17_7(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}else if( uBlendMode == 12 ){\\n\\t\\tcolor = blendLinearBurn_15_5(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}else if( uBlendMode == 13 ){\\n\\t\\tcolor = blendLinearDodge_14_4(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}else if( uBlendMode == 14 ){\\n\\t\\tcolor = blendLinearLight_1_6(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}else if( uBlendMode == 15 ){\\n\\t\\tcolor = blendMultiply_18_17(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}else if( uBlendMode == 16 ){\\n\\t\\tcolor = blendNegation_10_16(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}else if( uBlendMode == 17 ){\\n\\t\\tcolor = blendNormal_8_15(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}else if( uBlendMode == 18 ){\\n\\t\\tcolor = blendOverlay_5_12(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}else if( uBlendMode == 19 ){\\n\\t\\tcolor = blendPhoenix_9_14(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}else if( uBlendMode == 20 ){\\n\\t\\tcolor = blendPinLight_4_9(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}else if( uBlendMode == 21 ){\\n\\t\\tcolor = blendReflect_11_10(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}else if( uBlendMode == 22 ){\\n\\t\\tcolor = blendScreen_20_19(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}else if( uBlendMode == 23 ){\\n\\t\\tcolor = blendSoftLight_21_20(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}else if( uBlendMode == 24 ){\\n\\t\\tcolor = blendSubtract_23_21(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}else if( uBlendMode == 25 ){\\n\\t\\tcolor = blendVividLight_6_2(bgColor.rgb, fgColor.rgb, uAmount);\\n\\t}\\n\\n\\tgl_FragColor = vec4(color, 1.0);\\n}\\n\\n\"\n\n//# sourceURL=webpack:///./src/shader/edit/002.frag?");

/***/ }),

/***/ "./src/shader/sketches/sketch.vert":
/*!*****************************************!*\
  !*** ./src/shader/sketches/sketch.vert ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = \"#define GLSLIFY 1\\n\" + __webpack_require__(/*! ../common/define.glsl */ \"./src/shader/common/define.glsl\") + \"\\n\\n\\n\\n\\nvarying vec2 vUv;\\n\\n\\nuniform float uZamount;\\nuniform float uRotationZ;\\nuniform float uTime2;\\n\\n\\n\\n\\n\\n//\\n// Description : Array and textureless GLSL 2D simplex noise function.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289_1_0(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec2 mod289_1_0(vec2 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec3 permute_1_1(vec3 x) {\\n  return mod289_1_0(((x*34.0)+1.0)*x);\\n}\\n\\nfloat snoise_1_2(vec2 v)\\n  {\\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\\n                      0.024390243902439); // 1.0 / 41.0\\n// First corner\\n  vec2 i  = floor(v + dot(v, C.yy) );\\n  vec2 x0 = v -   i + dot(i, C.xx);\\n\\n// Other corners\\n  vec2 i1;\\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\\n  //i1.y = 1.0 - i1.x;\\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\\n  // x1 = x0 - i1 + 1.0 * C.xx ;\\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\\n  vec4 x12 = x0.xyxy + C.xxzz;\\n  x12.xy -= i1;\\n\\n// Permutations\\n  i = mod289_1_0(i); // Avoid truncation effects in permutation\\n  vec3 p = permute_1_1( permute_1_1( i.y + vec3(0.0, i1.y, 1.0 ))\\n    + i.x + vec3(0.0, i1.x, 1.0 ));\\n\\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\\n  m = m*m ;\\n  m = m*m ;\\n\\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\\n\\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\\n  vec3 h = abs(x) - 0.5;\\n  vec3 ox = floor(x + 0.5);\\n  vec3 a0 = x - ox;\\n\\n// Normalise gradients implicitly by scaling m\\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\\n\\n// Compute final noise value at P\\n  vec3 g;\\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\\n  return 130.0 * dot(m, g);\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\nmat4 rotationMatrix(vec3 axis, float angle)\\n{\\n  axis = normalize(axis);\\n  float s = sin(angle);\\n  float c = cos(angle);\\n  float oc = 1.0 - c;\\n\\n  return mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\\n    0.0,                                0.0,                                0.0,                                1.0);\\n}\\n\\n\\n\\n\\n\\nvoid main(){\\n  vUv = uv;\\n\\n  vec3 _position = position;\\n\\n  if(uZamount == 0.0){\\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n\\n\\n  } else {\\n    \\n    _position.z = snoise_1_2(_position.xy*(uTime2*0.1)) * uZamount;\\n  }\\n\\n  \\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(_position, 1.0);\\n}\\n\"\n\n//# sourceURL=webpack:///./src/shader/sketches/sketch.vert?");

/***/ })

/******/ });